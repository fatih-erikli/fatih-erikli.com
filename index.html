<!DOCTYPE html>
<html lang="en">

<head>
  <title>Fatih Erikli</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="google-site-verification" content="6J7qtw4WxlMyJSrsrQPb5AhWCln_bQIEuWOtoX8EzYI" />
  <link rel="icon" type="image/png" href="favicon.png" />
  <link rel="stylesheet" href="index-grid.css?8249bd1512c34e728668ea1a52b7dd96" />
  <link rel="stylesheet" href="styles.css?8249bd1512c34e728668ea1a52b7dd96" />
  <script>
    document.addEventListener("keydown", (event) => {
      if (event.code === "Enter") {
        const elementWithRoleLink = event.target
          .querySelector("[role='link']");
        if (elementWithRoleLink) {
          location.href = elementWithRoleLink.getAttribute("href");
        }
      }
    });
  </script>
</head>

<body>

  
  <div class="sketches">
  <h3 style="text-align: right; padding: 2rem;">Sketches</h3>
  <div class="row" style="background-color: #f6f6f6">
    <div style="width: 600px"><img src="nft-15.png" /></div>
    <div style="width: 360px">
      <img src="nft-8.png" />
      <div style="padding: 1rem">
        Sketched with cubic bezier curves which has two control points to
        control the curve of two points in a cartesian coordinate space.
      </div>
    </div>
  </div>
  <div class="row" style="background-color: #f6f6f6">
    <div style="width: 360px">
      <img src="nft-3.png" />
      <div style="padding: 1rem">
        This space intentionaly left blank.
      </div>
    </div>
    <div style="width: 600px; height: 470px; overflow: hidden">
      <img src="nft-2.png" />
    </div>
  </div>
  <div class="row" style="background-color: #f6f6f6">
    <div style="width: 600px"><img src="drawing-1.png" /></div>
    <div style="width: 360px; height: 340px; overflow: hidden">
      <div style="padding: 1rem">
        The illustration application is built with simple web technologies
        (React, that's all), that allows you to code to complete your drawing
        when the application is not enough to abstract your shapes, allows you
        to draw the strokes in a vector format, and prints them in a
        two-dimensional canvas.
      </div>
    </div>
  </div>


  <h3 style="text-align: right; padding: 2rem;">Blog</h3>
</div>
<div aria-label="personal web page" role="feed" aria-busy="false">
  <div role="heading" class="sidebar">
  <br />
  <a href="/" id="home-link">
    <img
      src="logo.png"
      width="190"
      alt="Fatih Erikli"
      style="margin-bottom: 1rem; height: 211.97px"
    />
    <span
      style="
        color: red;
        border: 1px solid black;
        font-size: 14px;
        width: 12px;
        padding-left: 2px;
        background-color: white;
        height: 17px;
        display: inline-block;
        position: absolute;
        margin-top: 40px;
        margin-left: 33px;
      "
      >X</span
    >
    <h1>Fatih Erikli</h1>
  </a>
  <p role="doc-subtitle">
    Full-stack software engineer, currently works for
    <a rel="nofollow" target="_blank" href="https://graphcommons.com"
      >Graph Commons</a
    >.
  </p>
  <div role="navigation" aria-label="Main">
    <a rel="nofollow" href="https://twitter.com/fatiherikliuniq" target="_blank"
      ><img src="./twitter-icon.svg" alt="twitter bird" />fatiherikliuniq</a
    >
    <a
      rel="nofollow"
      href="https://instagram.com/fatiherikliuniq"
      target="_blank"
      ><img src="./instagram.svg" alt="instagram" />0x012345</a
    >
  </div>
  <div area-label="Projects" class="projects">
    <h5>Projects</h5>
    <a href="https://fatih-erikli.github.io/sketchbook">
      <span style="background: #ffc28c"></span>
      Sketchbook</a
    >
    <p>Distraction free drafting application.</p>
    <a href="https://fatih-erikli.github.io/time-tracker">
      <span style="background: rgb(40, 40, 255)"></span>
      Time tracker</a
    >
    <p>Time tracker for freelancers and contractors.</p>
    <a href="https://fatih-erikli.github.io/dark-rectangles">
      <span style="background: rgb(40, 40, 40)"></span>
      Dark rectangles</a
    >
    <p>Figma-style zoomable and pannable area implemented in React.</p>
  </div>
</div>

  <div aria-label="blog posts" role="list" tabindex="-1">
    <article role="listitem" aria-posinset="0" tabindex="-3">
      <h3 aria-label="Title"><a role="link" href="indexeddb-transactional-database-in-client-side.html">IndexedDB: High-performance transactional database in client side</a></h3>
      <time>04 Dev, 2021</time>
      <div aria-label="Description" role="contentinfo" class="post-preview"><p>As you may already know, HTTP is a stateless protocol. The communication
between the client and server happens with some flags sent by client and server mutually.
It means, we actually don't really know which user is authenticated. User
is sending their session id via HTTP cookies and we (server) retrieve the related record
from the database, and prepare the page response with the information of
authenticated user.</p>
<ul>
<li><a href="creating-a-web-server-in-asyncio.html">Creating a web-server in AsyncIO</a></li>
</ul>
<p>To persist a data (storing data in client-side), we have the following options currently.</p>
<ul>
<li>Cookies</li>
<li>LocalStorage</li>
<li>SessionStorage</li>
<li>IndexedDB</li>
</ul>
<p>Each of them is important and has specific use cases in current state of web technologies.</p>
<h3>Cookies</h3>
<p>The oldest way to store a data in client side. We write the http cookies in server side
with an HTTP HEADER (SET_COOKIES) and prepare the http response with them. The information is
readable both in server side and client side.</p>
<h3>LocalStorage and SessionStorage</h3>
<p>Both of them has the same API to interact. The difference between them is, the information
is deleted when you close the page in SessionStorage. The LocalStorage stores the data
permanently until you delete them manually.</p>
<p>It is a key-value store and stores only Strings.</p>
<h3>IndexedDB</h3>
<p>IndexebDB is a database as same as relational databases such as PostgreSQL and MySQL.</p>
<p>It is a transactional database. You basically create a transaction in order to
write something to the database, and commit the transaction after your operations.
It makes it safer.</p>
<p>It is a key-value store and stores all Javascript types such as:</p>
<ul>
<li>Arrays</li>
<li>Objects</li>
<li>Booleans</li>
<li>Blob</li>
<li>And others.</li>
</ul>
<h3>Lets go with an example</h3>
<p>We are going to store a work-log entries. Lets imagine an application, the user is logging
the time of their work on a specific task, and creating a report
of them.</p>
<p>IndexedDB has a low-level database API. You have to create the database
instance when it is needed, and create a transaction when you manipulate your data,
and specify the transactions mode manually. In my opinion, it is important to
know all of that information when you deal with a database in order to keep
the integrity of your data safe.</p>
<pre><code class="language-javascript">const STORE_NAME_WORK_LOG = &quot;work-log&quot;;

async function getIndexedDbInstance() {
  return new Promise(async (resolve) =&gt; {
    const DB_NAME = &quot;time-tracker&quot;;
    const DB_VERSION = 1;
    const indexedDbRequest = indexedDB.open(DB_NAME, DB_VERSION);

    indexedDbRequest.onupgradeneeded = function () {
      const documentObjectsStore = indexedDbRequest.result.createObjectStore(
        STORE_NAME_WORK_LOG,
        {
          autoIncrement: false,
        }
      );
      documentObjectsStore.createIndex(&quot;dateCreation&quot;, &quot;dateCreation&quot;, {
        unique: false,
      });
    };
    indexedDbRequest.onsuccess = function () {
      resolve(indexedDbRequest.result);
    };
  });
}
</code></pre>
<p>As you may noticed, we are able to version the database scheme. The number we indicate
is not the version of the database (which is IndexedDB 3.0), but the schema that
you are currently creating. When you update your database schema (such as indexes and
store), you need to increase this number, and the client will request an upgrade
to update their database schemas.</p>
<p>The request of upgrade is an event that we can listen to. In case of an upgrade
request, we are creating our database schema and indexes.</p>
<pre><code class="language-javascript">function promisifyOnSuccess(request) {
  // This is not so much needed, probably there is
  // a better way to handle it, but I keep it for now :)
  return new Promise((resolve) =&gt; {
    request.onsuccess = (event) =&gt; {
      resolve(event.target.result);
    };
  });
}

export async function fetchWorkLogEntries() {
  const promise = new Promise(async (resolve) =&gt; {
    const db = await getIndexedDbInstance();
    const transaction = db.transaction(STORE_NAME_WORK_LOG, &quot;readonly&quot;);
    const objectStore = transaction.objectStore(STORE_NAME_WORK_LOG);
    const dateIndex = objectStore.index(&quot;dateCreation&quot;);
    const keys = await promisifyOnSuccess(dateIndex.getAllKeys());
    const promises = keys.map((key) =&gt;
      promisifyOnSuccess(objectStore.get(key))
    );
    const results = await Promise.all(promises);
    const resultsWithKeys = keys.map((key, index) =&gt; ({
      key,
      ...results[index],
    }));
    resolve(resultsWithKeys);
  });

  return promise;
}
</code></pre>
<p>This is a ready-only query. We retrieve all the work log items with the index of
<code>dateCreation</code>. This is how the indexes work. We created that index when the user
is asked for an upgrade.</p>
<p>The <code>dateCreation</code> index gives your data sorted by chronologically. Without
this index, you will receive your records in a random order (of course it is not random,
but you will not get them in a chronological order).</p>
<p>This is why IndexedDB is called as IndexedDB. If you try to implement the same
structure with LocalStorage, you will need to store them with basic array sorting
function in Javascript, and obviously it is going to be crashed when you have
more than thousand numbers of records.</p>
<p>If you have noticed, I also keep the object's own ID inside the stored value. It
eases the development when you list and print those records with ReactJS.</p>
<pre><code class="language-javascript">export async function createWorkLogEntry(payload, uniqueId) {
  const promise = new Promise(async (resolve) =&gt; {
    const db = await getIndexedDbInstance();
    const transaction = db.transaction(STORE_NAME_WORK_LOG, &quot;readwrite&quot;);
    const objectStore = transaction.objectStore(STORE_NAME_WORK_LOG);
    const key = uniqueId || generateUniqueID();
    objectStore.put(
      {
        ...payload,
        dateCreation: payload.dateCreation || new Date().toJSON(),
        key,
      },
      key
    ).onsuccess = resolve;
  });
  return promise;
}
</code></pre>
<p>This is a readwrite transaction. I keep the unique IDs as UUID (Universally Unique Identifier)
instead of an increasing number. If you don't specify a key, IndexedDB will increment
a number as a PrimaryKey. I don't find it useful in real world applications, basically
the user can increment the number and find other irrelevant records and confuse us :)</p>
<p><a href="https://datatracker.ietf.org/doc/html/rfc4122">A Universally Unique Identifier (UUID) URN Namespace</a></p>
<p>This is all. You can also read the source code
of a time tracker application that uses IndexedDB.</p>
<ul>
<li><a href="https://fatih-erikli.github.io/time-tracker">Time tracker</a></li>
</ul>
<p>Happy hacking!</p></div>
    </article>
    

    <article role="listitem" aria-posinset="1" tabindex="-4">
      <h3 aria-label="Title"><a role="link" href="creating-a-web-server-in-asyncio.html">Creating a web-server with AsyncIO</a></h3>
      <time>29 Nov, 2021</time>
      <div aria-label="Description" role="contentinfo" class="post-preview"><p>AsyncIO is a built-in python library to write concurrent
code with a new language keywords "async" and "await'. AsyncIO landed
into python in 3.3 version. Since the Python2 is no longer supported,
AsyncIO will be our swiss army knife to handle:</p>
<ul>
<li>Network operations</li>
<li>Subprocesses</li>
<li>Distributed tasks</li>
</ul>
<p>And many more.</p>
<h3>What does concurrent mean?</h3>
<p>In computer science, concurrency means the ability to execute different parts of the 
program simulatanoeusly. In concurrent programming, we write our functions as partial units
that can be executed as parallel (each of them working at the same time), or synchronously
(each of them working in a following order, not at the same time), without affecting the
final result.</p>
<p>Concurency tools helps us to make an abstraction to write functions can be worked in a
parallel way or in a sync way. The piece of function or code will not be aware that 
it is working in a parallel or in a synchronous order.</p>
<figure>
<img src="public/concurrent-task-execution.svg" style="width: 100%" />
<figcaption>Parallel vs Synchronous execution</figcaption>
</figure>

<p>In the figure above, we see the same tasks set (could be a whole function)
running as concurrent (in parallel) and synchronously. As the time moves,
the tasks in synchronous order moves in parallel to the time. Only one
task is running at a moment; it other words, a one task needs to be ran
in order to execute the next function.</p>
<p>In concurrent version of the implementation, all the tasks starts to run
at the same moment, and some tasks are finished before some others tasks.</p>
<p>The syncronous way of programming is the way of we program the things from the
very beginning. What we have learned until this time was synchronous way of programming.
There is no something special to be done in order to achieve this style programming.</p>
<p>In concurrent functions, we need special data types and structure to check if a task
is running, failed, or completed. Also we need to be able to wait until a specific task
or a task set to be completed. In Python programming language, with 3.3. version,
<code>async</code> and <code>await</code> was keywords introduced for handling concurrent operations.</p>
<h3>How does the HTTP protocol work</h3>
<p>We are going to create an HTTP server to play with <code>AsyncIO</code> library. Network operations
are the most popular use case for concurrent operations. Because we want to serve our
functions to as many as users possible at a time. One long lasting process should not
block the execution of functions for other users. This is a perfect use case for examples.</p>
<figure>
<img src="public/http-diagram.svg" style="width: 100%" />
<figcaption>Very simple HTTP workflow</figcaption>
</figure>

<h3>Streams</h3>
<p>Streams are data structures to work with network connections. An http server 
and an http request basically corresponds the two pairs of an socket operation;
one pair is sending an information, the other pair is receiving the information.</p>
<p>HTTP server is a TCP server running on a specific port. The default HTTP port is <code>:80</code>.
When you connect to a web-site, you connect to the server is running on <code>:80</code> port 
on a machine. You don't see the <code>:80</code> port, because it is default. If you try to connect
to a different port, you need to specificy the port you want to connect with a double-colon;
as an example: <code>https://python.org:8888</code>, even though this is not a correct use-case in practice, because
the default port for an HTTPS connection is <code>443</code>.</p>
<p>Let's go step by step and create a TCP server first.</p>
<pre><code class="language-python">import asyncio

async def pong(reader, writer):
    data = await reader.read(100)
    writer.write(b'pong')
    await writer.drain()
    writer.close()

async def main():
    server = await asyncio.start_server(pong, '127.0.0.1', 8888)
    async with server:
        await server.serve_forever()

asyncio.run(main())
</code></pre>
<p>We have created a ping pong application. When a client send a message to our server,
we will respond with <code>pong</code>. It's a simple application.</p>
<h3>How do we connect to a TCP server?</h3>
<p>Let's go with telnet application first; we don't
serve with an http response yet.</p>
<pre><code>$ my-blog % telnet 127.0.0.1 8888
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</code></pre>
<p>Telnet has it's own way of communication as you can notice in response.
We will write "ping" here.</p>
<pre><code>ping
pong
Connection closed by foreign host.
</code></pre>
<p>We received a pong response. This is how we communicate with servers. What happens when we
open this URL with a browser? The answer is; most of the modern browsers will show an error
message to the user indicating the http response is not valid.</p>
<p>We need to prepare a well-formatted http response to the user.</p>
<pre><code class="language-python">def http_document(content, status_code):
    return '\n'.join((
        f'HTTP/1.1 {status_code} OK',
        f'Content-Length: {len(content)}',
        'Content-Type: text/html',
        'Server: almost-an-nginx',
        '\r',
        content
    ))

def prepare_html(content, status_code=200):
    html = f'&lt;!DOCTYPE html&gt;{content}'
    return http_document(html, status_code)
</code></pre>
<p>We will respond in that way. We need to update our server function accordingly:</p>
<pre><code class="language-python">async def serve(reader, writer):
    data = await reader.read(100)
    writer.write(str.encode(prepare_html()))
    # this is where we prepare the response
    await writer.drain()
    writer.close()
</code></pre>
<p>We respond with the same http response does not matter where the current user landed.
The browser sends us a message which is formatted as same as http response. This
message is defined by HTTP protocol.</p>
<p>So the HTTP protocol has two pairs; one is Request and the other one is Response.
We prepared the http response. Now we need to process the http request.
We have not opened the message package in our server yet. Let's go further.</p>
<pre><code class="language-python">async def serve(reader, writer):
    data = await reader.read(100)
    message = data.decode()
</code></pre>
<p>The message is the http request itself. Lets dive into it.</p>
<pre><code>GET /favicon.ico HTTP/1.1
Host: 127.0.0.1:8888
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X
</code></pre>
<p>It will be something like that. Did you notice something? The User-agent
is cropped. Why is that happening? Answer is, we read only 100 bytes of the
message.</p>
<p>There is an http server implementation in Python's builtin library. It reads
<code>65537</code> bytes of the incoming message, which is the max limit that the server
can interpret. There is no limit; it is defined by your needs;
although the http request will not be greather than that specified number in practice.
The server respond's with <code>REQUEST_URI_TOO_LONG</code> http response if the 
receive message is greather than that number.</p>
<p>I trust Python's code so I will use the same size. I updated the server
accordingly and received the full http request message.</p>
<pre><code>GET / HTTP/1.1
Host: 127.0.0.1:8888
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:94.0)
Accept: text/html,application/xhtml+xml,application/xml;
Accept-Language: en-US,en;
</code></pre>
<p>The http request starts with the http method performed by user. Browser makes
the request always with <code>GET</code> method when you visit a URL. Other methods has
different use cases; such as form submissions. When the user makes a form
submission; it's sent as <code>POST</code> method. It does not have to be <code>POST</code> necessarily;
although it is practical and convenient handle the form submissions with <code>POST</code> method,
because the browser is informing the user like "Do you really submit the form again?"
when they refresh the page after clicking submit button.</p>
<p>The second parameter after the method is the path; which is the most important
parameter in our case; it specifies the path which the user wants to land on.
We can simply assume that <code>/</code> means the user is on the home-page. The third parameter after the path is the HTTP version. Currently browsers
send HTTP/1.1 version.</p>
<p>It's not hard to parse that document; most of the cases we only do need to know the method
of request, the path, and the request body depending on the request method.</p>
<pre><code class="language-python">def handle_post(method, request_body):
    import json
    input_json = json.loads(request_body)
    message = input_json['message']
    return prepare_html(f'&lt;h3&gt;{message}&lt;/h3&gt;')

ROUTES = {
    '/post-something': handle_post,
    '/':
        lambda method, request_body:
            prepare_html('&lt;h3&gt;Home page&lt;/h3&gt;'),
    '/about':
        lambda method, request_body:
            prepare_html('&lt;h3&gt;About page&lt;/h3&gt;')
}

async def serve(reader, writer):
    data = await reader.read(65537)
    message = data.decode()
    [first_line, *headers, request_body] = (message.split('\n'))
    [method, path, version] = first_line.split()

    handler = ROUTES.get(path)

    if handler is None:
        writer.write(str.encode(prepare_html('Not found', 404)))
    else:
        writer.write(str.encode(handler(method, request_body)))

    await writer.drain()
    writer.close()
</code></pre>
<p>Simply we created a router. Our web server is able to handle the request methods
and requested paths by the user. The last line of the http request is the request body;
which is the payload submitted by the client.</p>
<p>In REST APIs, usually the request body is sent as a stringified JSON document.
We can use python's json module to parse that JSON document.</p>
<p>When the user calles the <code>/post-something</code> with a valid json body; we respond
an html document with the message specified in that json package.</p>
<p>I use <code>httpie</code> package to send http commands via command lines. Here's how
I am testing my <code>/post-something</code> endpoint.</p>
<pre><code>$ http post &quot;127.0.0.1:8888/post-something&quot;
message=&quot;lorem ipsum dolor sit amet&quot;
HTTP/1.1 200 OK
Content-Length: 50
Content-Type: text/html
Server: almost-an-nginx

&lt;!DOCTYPE html&gt;&lt;h3&gt;lorem ipsum dolor sit amet&lt;/h3&gt;
</code></pre>
<p>In practice, we need to respond with a JSON for an endpoint which is expecting
a json body to process.</p>
<p>It is simple. We will create a different function instead of <code>prepare_html</code>.</p>
<pre><code class="language-python">def json_response(payload):
    return http_document(json.dumps(payload), 200)
</code></pre>
<p>We call the same endpoint; as you will notice we respond with stringified json
instead of an html document.</p>
<pre><code>$ http post &quot;127.0.0.1:8888/post-something&quot; message=&quot;lorem ipsum dolor sit amet&quot;
HTTP/1.1 200 OK
Content-Length: 41
Content-Type: text/html
Server: almost-an-nginx

{
    &quot;message&quot;: &quot;lorem ipsum dolor sit amet&quot;
}
</code></pre>
<p>Happy hacking.</p></div>
    </article>
    

    <article role="listitem" aria-posinset="2" tabindex="-5">
      <h3 aria-label="Title"><a role="link" href="creating-user-authentication-in-cloudflare-workers.html">Developing a User authentication in CF worker</a></h3>
      <time>02 Dev, 2021</time>
      <div aria-label="Description" role="contentinfo" class="post-preview"><p>I have been trying serverless computing platforms in last years. Basically these platforms allows you
to publish functions and execute them periodically, or by triggering it
with an HTTP request.</p>
<p>What I have tried so far:</p>
<ul>
<li>Amazon Lambda</li>
<li>CloudFlare</li>
<li>Serverless Framework (This is not a platform; but a framework that helps you to publish your architecture in
 any platform)</li>
</ul>
<p>In this blog post I will share an example in CloudFlare. Why so?</p>
<ul>
<li>It's free</li>
<li>I find the control panel more user and developer friendly</li>
<li>They have a strong development community</li>
</ul>
<p>We will create a user authentication by using Cloudflare workers.</p>
<p>Let's write down what we are going to build first. We will have three API endpoints.</p>
<ul>
<li>Registration</li>
<li>Login</li>
<li>Auth</li>
</ul>
<p>Registration and login is obvious. Auth endpoint will help us to authenticate user
after the login process. We will store the <code>auth_token</code> provided us from the login or
registration endpoint; and reuse them later (when the user refresh the page) to reauthenticate
them again.</p>
<h3>Persistance layer</h3>
<p>First of all; we need to create a KV store; which is the database (or key-value store) of CloudFlare.</p>
<p><a href="https://developers.cloudflare.com/workers/runtime-apis/kv">https://developers.cloudflare.com/workers/runtime-apis/kv</a></p>
<p>You can create a KV store on cloudflare panel; or you can create it with <a href="https://developers.cloudflare.com/workers/cli-wrangler">wrangler</a>
command line tool.</p>
<p>Let's start with Registration endpoint.</p>
<pre><code class="language-javascript">const sha256 = require('crypto-js/sha256')
const cryptoJs = require('crypto-js')
const jwt = require('jsonwebtoken')

addEventListener('fetch', event =&gt; {
  event.respondWith(handleRequest(event.request))
})

/**
 * Simple authentication
 * @param {Request} request
 */
async function handleRequest(request) {
  const url = new URL(request.url)
  const { pathname } = url
  let response = { pathname }
  switch (pathname) {
    case '/register': {
      const { username, password } = await request.json()

      const user = await YOURKVSTORE.get(`user:${username}`)
      if (user) {
        response = {
          error: 'User exists.',
        }
        break
      }

      const hashedPassword = sha256(password).toString(cryptoJs.enc.Hex)
      // this is important
      await YOURKVSTORE.put(`user:${username}`, hashedPassword)

      const token = jwt.sign({ username }, TOKEN_KEY, {
        expiresIn: '2h',
      })

      await YOURKVSTORE.put(`user_token:${token}`, username)

      response = {
        token,
      }
      break
    }
  }
  return new Response(JSON.stringify(response), {
    headers: {
      'content-type': 'text/json'
    },
  })
}
</code></pre>
<p>This is how an event-driven computing-ready function looks like in any platform.
It is not so different than creating a controller in a http or Rest API framework;
we have a request body and we create a response with that.</p>
<h3>Most important thing</h3>
<p>You cannot store the user's password in your database. You need to hash them with a
hashing algorithm; such as sha256, and save them.</p>
<p>When the user types username and password in login page; we need to hash the
password provided by user; and match the hashed pairs, instead of raw password.
This is very important.</p>
<p>After the hashing algorithm; we use JWT (JSON Web Token) to create a token
that we can authenticate the user without username and password.</p>
<pre><code class="language-javascript">/**
 * Simple authentication
 * @param {Request} request
 */
async function handleRequest(request) {
  const url = new URL(request.url)
  const { pathname } = url
  let response = { pathname }
  switch (pathname) {
    case '/login': {
      const { username, password } = await request.json()
      const hashedPassword = sha256(password).toString(cryptoJs.enc.Hex)
      const storedPassword = await VECTORIAL.get(`user:${username}`)
      if (storedPassword === hashedPassword) {
        const token = jwt.sign({ username }, TOKEN_KEY, {
          expiresIn: '2h',
        })

        await VECTORIAL.put(`user_token:${token}`, username)

        response = {
          token,
        }
      } else {
        response = {
          error: 'Invalid credientials.',
        }
      }
      break
    }
    case '/auth': {
      const { token } = await request.json()

      let user

      try {
        user = jwt.verify(token, TOKEN_KEY)
      } catch (e) {
        response = {
          error: 'Invalid signature.',
        }
      }

      if (user) {
        const username = await VECTORIAL.get(`user_token:${token}`);
        if (!username) {
          response = {
            error: 'Invalid signature.',
          }
        } else {
          response = {
            username,
          }
        }
      }
      break
    }
    case '/register': {
      const { username, password } = await request.json()

      const user = await VECTORIAL.get(`user:${username}`)
      if (user) {
        response = {
          error: 'User exists.',
        }
        break
      }

      const hashedPassword = sha256(password).toString(cryptoJs.enc.Hex)
      await VECTORIAL.put(`user:${username}`, hashedPassword)

      const token = jwt.sign({ username }, TOKEN_KEY, {
        expiresIn: '2h',
      })

      await VECTORIAL.put(`user_token:${token}`, username)

      response = {
        token,
      }
      break
    }
  }
  return new Response(JSON.stringify(response), {
    headers: {
      'content-type': 'text/plain',
    },
  })
}
</code></pre>
<p>I wrote the code as clean as possible to not complicate things by explaining
them with my English :)</p>
<h3>CORS settings</h3>
<p>We have created the API with workers. There's one thing needs to be done in the code
in order to connect them via a browser; CORS (Cross Origin Resource Sharing) settings.
Basically we need to whitelist a domain or url that we are going to connect to
the API we have created.</p>
<pre><code>async function handleRequest(request) {
  // ...
  return new Response(JSON.stringify(response), {
    headers: {
      'content-type': 'text/plain',
      'Access-Control-Allow-Origin': '*', // Whildcard allows all domains
      'Access-Control-Allow-Methods': 'GET,HEAD,POST,OPTIONS',
      'Access-Control-Max-Age': '86400',
    },
  })
}
</code></pre>
<p>Yon can type the domain instead of the asteriks whildcard.</p>
<h3>Deployment</h3>
<p>I use <a href="https://developers.cloudflare.com/workers/cli-wrangler">wrangler</a> to manage
my workers. You can write and publish them on cloudflare dashboard as well. I find command-line
tool more useful when you develop something more complicated.</p>
<pre><code>$ my-cloudflare-worker % wrangler publish
✨  Built successfully, built project size is 213 KiB.
✨  Successfully published your script to
https://vectorial-cloudflare-worker.fatih-erikli.workers.dev

</code></pre>
<p>Let's try our endpoints.</p>
<p>I am going to register myself.</p>
<pre><code>$ http post &quot;https://1.fatih-erikli.workers.dev/register&quot;
username=benfatih password=hello
HTTP/1.1 200 OK
Access-Control-Allow-Methods: GET,HEAD,POST,OPTIONS
Access-Control-Allow-Origin: *
Access-Control-Max-Age: 86400
CF-RAY: 6b77697eab936b36-AMS
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/plain
Date: Thu, 02 Dec 2021 20:47:45 GMT
NEL: {&quot;success_fraction&quot;:0,&quot;report_to&quot;:&quot;cf-nel&quot;,&quot;max_age&quot;:604800}
Server: cloudflare
Transfer-Encoding: chunked
Vary: Accept-Encoding

{
    &quot;token&quot;: &quot;Wohoo yay, it worked. Of course I cropped my auth token. Its mine&quot;
}
</code></pre>
<p>It worked :) We are going to authenticate ourselves with the token returned by our endpoint.</p>
<pre><code>$ http post &quot;https://1.fatih-erikli.workers.dev/auth&quot; token=mytoken
HTTP/1.1 200 OK
Access-Control-Allow-Methods: GET,HEAD,POST,OPTIONS
Access-Control-Allow-Origin: *
Access-Control-Max-Age: 86400
CF-RAY: 6b776bd4edcb1ead-AMS
Connection: keep-alive
Content-Length: 23
Content-Type: text/plain
Date: Thu, 02 Dec 2021 20:49:20 GMT
NEL: {&quot;success_fraction&quot;:0,&quot;report_to&quot;:&quot;cf-nel&quot;,&quot;max_age&quot;:604800}
Server: cloudflare
Vary: Accept-Encoding

{
    &quot;username&quot;: &quot;benfatih&quot;
}

</code></pre>
<p>Yay. We are able to authenticate with an authentication token instead of username and password.</p>
<p>That's all :)</p>
<p>Happy hacking!</p></div>
    </article>
    </div>
</div>

</body>

</html>